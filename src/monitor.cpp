/*
  __  __             _ _
 |  \/  | ___  _ __ (_) |_ ___  _ __
 | |\/| |/ _ \| '_ \| | __/ _ \| '__|
 | |  | | (_) | | | | | || (_) | |
 |_|  |_|\___/|_| |_|_|\__\___/|_|

# A Sink Plugin that monitors timings of other source and filter agents
# Generated by the command: plugin -t sink monitor_plugin -o
# Hostname: Fram-IV.local
# Creation date: 2026-01-30T10:32:10.047+0100
# NOTICE: MADS Version 2.0.0
*/

// Mandatory included headers
#include <chrono>
#include <map>
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>
#include <sink.hpp>
#include <iomanip>

#define ESC "\x1B"


// other includes as needed here

// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "monitor"
#endif

// Load the namespaces
using namespace std;
using json = nlohmann::json;

struct TimingData {
  chrono::system_clock::time_point last = chrono::system_clock::now();
  string machine;

  void seen() { last = chrono::system_clock::now(); }

  TimingData(double timecode = 0, string m = "") {
    machine = m;
    seen();
  }

  friend ostream &operator<<(ostream &os, const TimingData &obj) {
    auto delay = (chrono::system_clock::now() - obj.last).count() / 1.0E6;
    os << "seen from " 
       << setw(18) << quoted(obj.machine) << ", "
       << setprecision(3) << scientific << delay << " s ago";
    return os;
  }
};

// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
class Monitor_pluginPlugin : public Sink<json> {

public:
  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

  // Implement the actual functionality here
  return_type load_data(json const &input, string topic = "") override {
    string id = topic + "/" + input.value("agent_id", "-");

    if (topic == "agent_event")
      return return_type::retry;
    cout << ESC"[1J" ESC"[H";
    cout << "Seen " << _timings.size() << " agents:" << endl;
    for (const auto &[k, v] : _timings) {
      cout << "  " << k << ": " << v << endl;
    }

    if (_timings.count(id)) {
      _timings.at(id).seen();
    } else {
      _timings[id] = TimingData(input.value("timecode", 0),
                                input.value("hostname", "unknown"));
    }
    return return_type::success;
  }

  void set_params(const json &params) override {
    Sink::set_params(params);
    _params.merge_patch(params);
  }

  // Implement this method if you want to provide additional information
  map<string, string> info() override { return {}; };

private:
  map<string, TimingData> _timings;
};

/*
  ____  _             _             _      _
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|
                |___/
Enable the class as plugin
*/
INSTALL_SINK_DRIVER(Monitor_pluginPlugin, json)

/*
                  _
  _ __ ___   __ _(_)_ __
 | '_ ` _ \ / _` | | '_ \
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|

For testing purposes, when directly executing the plugin
*/
int main(int argc, char const *argv[]) {
  Monitor_pluginPlugin plugin;
  json input, params;

  // Set example values to params
  params["test"] = "value";

  // Set the parameters
  plugin.set_params(params);

  // Process data
  plugin.load_data(input);

  return 0;
}
