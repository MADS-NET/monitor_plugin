/*
  __  __             _ _
 |  \/  | ___  _ __ (_) |_ ___  _ __
 | |\/| |/ _ \| '_ \| | __/ _ \| '__|
 | |  | | (_) | | | | | || (_) | |
 |_|  |_|\___/|_| |_|_|\__\___/|_|

# A Sink Plugin that monitors timings of other source and filter agents
# Generated by the command: plugin -t sink monitor_plugin -o
# Hostname: Fram-IV.local
# Creation date: 2026-01-30T10:32:10.047+0100
# NOTICE: MADS Version 2.0.0
*/

// Mandatory included headers
#include <array>
#include <chrono>
#include <iomanip>
#include <map>
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>
#include <rang.hpp>
#include <sink.hpp>

#define ESC "\x1B"

// other includes as needed here

// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "monitor"
#endif

// Load the namespaces
using namespace std;
using namespace rang;
using json = nlohmann::json;

struct TimingData {
  chrono::system_clock::time_point last = chrono::system_clock::now();
  string machine, topic, id;
  double yellow, red;
  array<int, 3> col_widths{18, 15, 15};

  void seen() { last = chrono::system_clock::now(); }

  TimingData(string m = "", string t = "", string i = "")
      : machine(m), topic(t), id(i) {
    seen();
  }

  friend ostream &operator<<(ostream &os, const TimingData &obj) {
    auto delay = (chrono::system_clock::now() - obj.last).count() / 1.0E6;
    os << setw(obj.col_widths[0]) << obj.machine << " | "
       << setw(obj.col_widths[1]) << obj.topic << " | "
       << setw(obj.col_widths[2]) << obj.id << " | " << setprecision(3)
       << scientific;
    if (delay >= obj.red)
      os << fg::red << delay << fg::reset;
    else if (delay >= obj.yellow)
      os << fg::yellow << delay << fg::reset;
    else
      os << fg::green << delay << fg::reset;
    return os;
  }
};

// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
class Monitor_pluginPlugin : public Sink<json> {

public:
  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

  // Implement the actual functionality here
  return_type load_data(json const &input, string topic = "") override {
    string id = topic + "/" + input.value("agent_id", "-");

    if (topic == "agent_event")
      return return_type::retry;
    cout << ESC "[1J" ESC "[H" << style::bold << "Seen " << _timings.size()
         << " agents:" << endl
         << setw(_col_widths[0]) << "host" << style::reset << " | "
         << style::bold << setw(_col_widths[1]) << "topic" << style::reset
         << " | " << style::bold << setw(_col_widths[2]) << "agent_id"
         << style::reset << " | " << style::bold << "elapsed (s)"
         << style::reset << endl;
    for (const auto &[k, v] : _timings) {
      cout << v << endl;
    }

    if (_timings.count(id)) {
      _timings.at(id).seen();
    } else {
      _timings[id] = TimingData(input.value("hostname", "unknown"), topic,
                                input.value("agent_id", "-"));
      _timings[id].yellow = _params["yellow"];
      _timings[id].red = _params["red"];
      _timings[id].col_widths = _col_widths;
    }
    return return_type::success;
  }

  void set_params(const json &params) override {
    Sink::set_params(params);
    _params["yellow"] = 0.1;
    _params["red"] = 1.0;
    _params["col_widths"] = {18, 15, 15};
    _params.merge_patch(params);

    try {
      _col_widths[0] = _params["col_widths"][0];
      _col_widths[1] = _params["col_widths"][1];
      _col_widths[2] = _params["col_widths"][2];
    } catch (const json::type_error &e) {
      cerr << fg::red << "Settings error: col_widths must be an array of 3 ints"
           << fg::reset << endl;
      exit(EXIT_FAILURE);
    }
  }

  // Implement this method if you want to provide additional information
  map<string, string> info() override { return {}; };

private:
  map<string, TimingData> _timings;
  array<int, 3> _col_widths;
};

/*
  ____  _             _             _      _
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|
                |___/
Enable the class as plugin
*/
INSTALL_SINK_DRIVER(Monitor_pluginPlugin, json)

/*
                  _
  _ __ ___   __ _(_)_ __
 | '_ ` _ \ / _` | | '_ \
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|

For testing purposes, when directly executing the plugin
*/
int main(int argc, char const *argv[]) {
  Monitor_pluginPlugin plugin;
  json input, params;

  // Set example values to params
  params["test"] = "value";

  // Set the parameters
  plugin.set_params(params);

  // Process data
  plugin.load_data(input);

  return 0;
}
