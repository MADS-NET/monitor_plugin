/*
  ____  _       _            _             _
 / ___|(_)_ __ | | __  _ __ | |_   _  __ _(_)_ __
 \___ \| | '_ \| |/ / | '_ \| | | | |/ _` | | '_ \
  ___) | | | | |   <  | |_) | | |_| | (_| | | | | |
 |____/|_|_| |_|_|\_\ | .__/|_|\__,_|\__, |_|_| |_|
                      |_|            |___/
# A Template for Monitor_pluginPlugin, a Sink Plugin
# Generated by the command: plugin -t sink monitor_plugin -o
# Hostname: Fram-IV-3.local
# Current working directory: /Users/p4010/Develop/MADS_plugins
# Creation date: 2026-01-30T10:32:10.047+0100
# NOTICE: MADS Version 2.0.0
*/

// Mandatory included headers
#include <chrono>
#include <map>
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>
#include <sink.hpp>
#include <sstream>

// other includes as needed here

// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "monitor"
#endif

// Load the namespaces
using namespace std;
using json = nlohmann::json;

struct TimingData {
  chrono::system_clock::time_point last = chrono::system_clock::now();
  string machine;

  void seen() { last = chrono::system_clock::now(); }

  TimingData(double timecode = 0, string m = "") {
    machine = m;
    seen();
  }

  string description() const {
    stringstream ss;
    ss << "seen from " << machine << " " << (chrono::system_clock::now() - last).count()/1.0E6 << "s ago";
    return ss.str();
  }
};

// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
class Monitor_pluginPlugin : public Sink<json> {

public:
  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

  // Implement the actual functionality here
  return_type load_data(json const &input, string topic = "") override {
    string id = topic + "/" + input.value("agent_id", "-");

    if (topic == "agent_event") return return_type::retry;
    cout << "\033[2J\033[0;0H";
    cout << "Seen " << _timings.size() << " agents:" << endl;
    for (const auto &[k, v] : _timings) {
      cout << "  " << k << ": " << v.description() << endl;
    }

    if (_timings.count(id)) {
      _timings.at(id).seen();
    } else {
      _timings[id] =
          TimingData(input.value("timecode", 0),
                     input.value("hostname", "unknown"));
    }
    return return_type::success;
  }

  void set_params(const json &params) override {
    // Call the parent class method to set the common parameters
    // (e.g. agent_id, etc.)
    Sink::set_params(params);

    // provide sensible defaults for the parameters by setting e.g.

    // then merge the defaults with the actually provided parameters
    // params needs to be cast to json
    _params.merge_patch(params);
  }

  // Implement this method if you want to provide additional information
  map<string, string> info() override {
    // return a map of strings with additional information about the plugin
    // it is used to print the information about the plugin when it is loaded
    // by the agent

    return {};
  };

private:
  // Define the fields that are used to store internal resources
  map<string, TimingData> _timings;
};

/*
  ____  _             _             _      _
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|
                |___/
Enable the class as plugin
*/
INSTALL_SINK_DRIVER(Monitor_pluginPlugin, json)

/*
                  _
  _ __ ___   __ _(_)_ __
 | '_ ` _ \ / _` | | '_ \
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|

For testing purposes, when directly executing the plugin
*/
int main(int argc, char const *argv[]) {
  Monitor_pluginPlugin plugin;
  json input, params;

  // Set example values to params
  params["test"] = "value";

  // Set the parameters
  plugin.set_params(params);

  // Process data
  plugin.load_data(input);

  return 0;
}
